apiVersion: v1
kind: ServiceAccount
metadata:
  name: feed-ingress
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: feed-ingress-privileged-psp
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: privileged-psp
subjects:
  - kind: ServiceAccount
    name: feed-ingress
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: feed-ingress
  namespace: kube-system
rules:
  - apiGroups:
      # Core group for services
      - ""
      # For ingress
      - "extensions"
    resources:
      - ingresses
      - namespaces
      - services
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - "extensions"
    resources:
      - ingresses/status
    verbs:
      - update
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: feed-ingress
  namespace: kube-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: feed-ingress
subjects:
  - kind: ServiceAccount
    name: feed-ingress
    namespace: kube-system
---
# Example deployment for launching feed-ingress, the nginx ingress controller.
#
apiVersion: apps/v1
kind: Deployment
metadata:
  name: feed-ingress
  namespace: kube-system
  labels:
    app: feed-ingress
spec:
  replicas: 3
  selector:
    matchLabels:
      app: feed-ingress
  template:
    metadata:
      labels:
        app: feed-ingress
    spec:

      # For GKE let's try add the pods directly to the LB rather than going via host networking
      # Listen directly on host interface, required so NLBs can contact nginx.
      # hostNetwork: true

      # Time to wait for requests to gracefully terminate when updating the deployment.
      # Needs to be at least as long as the -drain-delay setting below, with a buffer for other teardown.
      # Recommend to set this to 2x -drain-delay.
      terminationGracePeriodSeconds: 60
      serviceAccountName: feed-ingress

      # Always restart on death.
      restartPolicy: Always

      containers:
      - image: europe-west1-docker.pkg.dev/core-platform-dev-poc348b/core-gcp/feed-ingress:latest
        name: feed-ingress

        resources:
          requests:
            cpu: "1"
            memory: 300Mi
          limits:
            memory: 300Mi

        ports:
        - hostPort: 8080
          containerPort: 8080
          name: ingress
          protocol: TCP
        - hostPort: 8081
          containerPort: 8081
          name: ingress-health
          protocol: TCP
        # Health port of the controller.
        - containerPort: 12082
          name: health
          protocol: TCP

        args:
        # Layer 7 global load balancer
        - gcp-glb

        # Ingress nginx port that NLBs will direct traffic towards.
        - --ingress-port=8080
        - --debug=true

        # Health port on nginx, used by NLBs to determine health.
        - --ingress-health-port=8081

        # Default security whitelist for ingress. Can be overridden with the sky.uk/allow annotation.
        - --ingress-allow=0.0.0.0/0

        # Health port for the controller to respond on.
        - --health-port=12082

        # Log level of nginx. Recommended to leave at error, or set to crit if too much spam.
        - --nginx-loglevel=error

        # How often to reload nginx if needed. Setting too low can cause 504s from the NLB in the case of heavy
        # ingress updates.
        - --nginx-update-period=5m

        # Attach to the NLBs with label sky.uk/KubernetesClusterIngressClass set to this value
        # and adopt ingress resources with a matching kubernetes.io/ingress.class value
        - --ingress-class=gcp-glb

        # Each worker uses a full cpu, so scale up vertically on a box by increasing this value.
        - --nginx-workers=1

        # Connections*workers needs to be less than available ephemeral ports. Linux default is 60999-32768=28231.
        - --nginx-worker-connections=20000

        # Needs to be greater than any frontend idle timeout.
        - --nginx-keepalive-seconds=304

        # CIDRs of the NLBs to trust X-Forwarded-For, for determining client IP allow/deny.
        - --nginx-trusted-frontends=10.0.0.0/8

        # Max number of idle connections to a backend.
        - --nginx-backend-keepalive-count=1024

        # Default max time for a request to a backend. Can be overridden by an annotation on the ingress resource.
        - --nginx-default-backend-timeout-seconds=5

        # Needs to be greater than 64 to support very large domain names.
        - --nginx-server-names-hash-bucket-size=128

        # Access logs turned on - add or remove the "-access-log" flag to turn them on/off.
        - --access-log
        - --access-log-dir=/var/log/nginx

        # Controller health determines readiness. This has no effect on ingress traffic from NLBs.
        readinessProbe:
          httpGet:
            path: /health
            port: 12082
            scheme: HTTP
          initialDelaySeconds: 1
          timeoutSeconds: 1
          periodSeconds: 1
          failureThreshold: 1

        # Only consider liveness of ingress itself, favouring uptime over controller health.
        livenessProbe:
          httpGet:
            path: /health
            port: 8081
            scheme: HTTP
          initialDelaySeconds: 30
          timeoutSeconds: 1
          periodSeconds: 10
          failureThreshold: 3

        # Access logs volume.
        volumeMounts:
        - name: nginx-log
          mountPath: /var/log/nginx

      volumes:
      - name: nginx-log
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: feed
  namespace: kube-system
  annotations:
    cloud.google.com/neg: '{"exposed_ports": {"8080":{"name": "feed"}}}'
spec:
  type: ClusterIP
  selector:
    app: feed-ingress
  ports:
    - port: 8080
      protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  name: feed-ingress
  namespace: kube-system
  annotations:
    cloud.google.com/neg: '{"ingress": true}'
    cloud.google.com/backend-config: '{"default": "feed"}'
spec:
  type: ClusterIP
  selector:
    app: feed-ingress
  ports:
    - port: 8080
      protocol: TCP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: external-feed
  namespace: kube-system
  annotations:
    kubernetes.io/ingress.class: "gce"
spec:
  rules:
    - http:
        paths:
          - path: /*
            pathType: ImplementationSpecific
            backend:
              service:
                name: feed-ingress
                port:
                  number: 8080
---
apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: feed
  namespace: kube-system
spec:
  healthCheck:
    port: 8081
    type: HTTP
    requestPath: /health
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: internal-feed
  namespace: kube-system
  annotations:
    kubernetes.io/ingress.class: "gce-internal"
spec:
  rules:
    - http:
        paths:
          - path: /*
            pathType: ImplementationSpecific
            backend:
              service:
                name: feed-ingress
                port:
                  number: 8080
